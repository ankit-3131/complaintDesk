import PDFDocument from 'pdfkit';
import Ticket from '../models/ticket.js';
import User from '../models/user.js';

function msToDuration(ms) {
  if (!ms) return '-';
  const totalMins = Math.round(ms / (60 * 1000));
  const hours = Math.floor(totalMins / 60);
  const mins = totalMins % 60;
  return `${hours}h ${mins}m`;
}

export async function monthlyReport(req, res) {
  try {
    const year = parseInt(req.query.year, 10) || new Date().getFullYear();
    const month = parseInt(req.query.month, 10);
    if (!month || month < 1 || month > 12) {
      return res.status(400).json({ message: 'Provide query params ?year=YYYY&month=MM' });
    }

    const start = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0));
    const end = new Date(Date.UTC(year, month, 1, 0, 0, 0));

    // find tickets created in that month (or updated/resolved in that month?)
    // we'll consider tickets whose createdAt is within the month
    const tickets = await Ticket.find({ createdAt: { $gte: start, $lt: end } }).populate('resolvedBy', 'name email');

    const total = tickets.length;
    const totalResolved = tickets.filter(t => t.status === 'Resolved').length;
    const totalOpen = tickets.filter(t => t.status !== 'Resolved').length;

    // compute resolve times for resolved tickets
    const resolvedTimes = tickets
      .filter(t => t.status === 'Resolved' && t.resolvedAt && t.createdAt)
      .map(t => t.resolvedAt.getTime() - t.createdAt.getTime());

    const avgResolveMs = resolvedTimes.length ? Math.round(resolvedTimes.reduce((a,b)=>a+b,0)/resolvedTimes.length) : 0;

    // Prepare the PDF
    const doc = new PDFDocument({ size: 'A4', margin: 50 });
    const filename = `monthly-report-${year}-${String(month).padStart(2,'0')}.pdf`;
    res.setHeader('Content-disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-type', 'application/pdf');

    const origAddPage = doc.addPage.bind(doc);
    doc.addPage = (...args) => {
      origAddPage(...args);
    };

    doc.on('pageAdded', () => {
      const bottom = doc.page.height - 40;
      doc.fontSize(8).fillColor('gray').text(`Generated: ${new Date().toISOString()}`, 50, bottom, { align: 'left' });
      doc.fontSize(8).fillColor('gray').text(`Page ${doc.page.number}`, 0, bottom, { align: 'center' });
    });

    doc.pipe(res);

    doc.fontSize(20).text(`Monthly Ticket Report`, { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(12).text(`Month: ${year}-${String(month).padStart(2,'0')}`);
    doc.text(`Generated: ${new Date().toISOString()}`);
    doc.moveDown();

    doc.fontSize(14).text('Summary', { underline: true });
    doc.moveDown(0.3);
    doc.fontSize(12).list([
      `Total tickets created: ${total}`,
      `Total resolved: ${totalResolved}`,
      `Total open / in progress: ${totalOpen}`,
      `Average resolve time: ${avgResolveMs ? msToDuration(avgResolveMs) : '-'} `
    ]);

    doc.moveDown();
  doc.fontSize(14).text('Tickets', { underline: true });
    doc.moveDown(0.3);

    // Table-like list
    tickets.forEach((t, idx) => {
      doc.fontSize(12).fillColor('black').text(`${idx+1}. ${t.title}`);
      const meta = [];
      meta.push(`Status: ${t.status}`);
      if (t.status === 'Resolved' && t.resolvedAt) {
        meta.push(`Resolved At: ${t.resolvedAt.toISOString()}`);
        meta.push(`Resolve Time: ${msToDuration(t.resolvedAt.getTime() - t.createdAt.getTime())}`);
      }
      doc.fontSize(10).fillColor('gray').text('   ' + meta.join(' • '));
      doc.moveDown(0.2);
      // add page break if approaching bottom
      if (doc.y > doc.page.height - 120) doc.addPage();
    });

    // Final footer on last page
    const bottom = doc.page.height - 40;
    doc.fontSize(8).fillColor('gray').text(`Report generated by ComplaintDesk — ${new Date().toLocaleString()}`, 50, bottom, { align: 'left' });

    doc.end();

  } catch (err) {
    console.error('monthlyReport error', err);
    res.status(500).json({ message: 'Server error' });
  }
}
